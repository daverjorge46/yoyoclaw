// Generated by scripts/protocol-gen-swift.ts â€” do not edit by hand
import Foundation

public struct CronAddParams: Codable, Sendable {
    public let name: String
    public let agentid: AnyCodable?
    public let description: String?
    public let enabled: Bool?
    public let deleteafterrun: Bool?
    public let schedule: AnyCodable
    public let sessiontarget: AnyCodable
    public let wakemode: AnyCodable
    public let payload: AnyCodable
    public let isolation: [String: AnyCodable]?

    public init(
        name: String,
        agentid: AnyCodable?,
        description: String?,
        enabled: Bool?,
        deleteafterrun: Bool?,
        schedule: AnyCodable,
        sessiontarget: AnyCodable,
        wakemode: AnyCodable,
        payload: AnyCodable,
        isolation: [String: AnyCodable]?
    ) {
        self.name = name
        self.agentid = agentid
        self.description = description
        self.enabled = enabled
        self.deleteafterrun = deleteafterrun
        self.schedule = schedule
        self.sessiontarget = sessiontarget
        self.wakemode = wakemode
        self.payload = payload
        self.isolation = isolation
    }
    private enum CodingKeys: String, CodingKey {
        case name
        case agentid = "agentId"
        case description
        case enabled
        case deleteafterrun = "deleteAfterRun"
        case schedule
        case sessiontarget = "sessionTarget"
        case wakemode = "wakeMode"
        case payload
        case isolation
    }
}

public struct CronRunLogEntry: Codable, Sendable {
    public let ts: Int
    public let jobid: String
    public let action: String
    public let status: AnyCodable?
    public let error: String?
    public let summary: String?
    public let runatms: Int?
    public let durationms: Int?
    public let nextrunatms: Int?

    public init(
        ts: Int,
        jobid: String,
        action: String,
        status: AnyCodable?,
        error: String?,
        summary: String?,
        runatms: Int?,
        durationms: Int?,
        nextrunatms: Int?
    ) {
        self.ts = ts
        self.jobid = jobid
        self.action = action
        self.status = status
        self.error = error
        self.summary = summary
        self.runatms = runatms
        self.durationms = durationms
        self.nextrunatms = nextrunatms
    }
    private enum CodingKeys: String, CodingKey {
        case ts
        case jobid = "jobId"
        case action
        case status
        case error
        case summary
        case runatms = "runAtMs"
        case durationms = "durationMs"
        case nextrunatms = "nextRunAtMs"
    }
}

public struct LogsTailParams: Codable, Sendable {
    public let cursor: Int?
    public let limit: Int?
    public let maxbytes: Int?

    public init(
        cursor: Int?,
        limit: Int?,
        maxbytes: Int?
    ) {
        self.cursor = cursor
        self.limit = limit
        self.maxbytes = maxbytes
    }
    private enum CodingKeys: String, CodingKey {
        case cursor
        case limit
        case maxbytes = "maxBytes"
    }
}

public struct LogsTailResult: Codable, Sendable {
    public let file: String
    public let cursor: Int
    public let size: Int
    public let lines: [String]
    public let truncated: Bool?
    public let reset: Bool?

    public init(
        file: String,
        cursor: Int,
        size: Int,
        lines: [String],
        truncated: Bool?,
        reset: Bool?
    ) {
        self.file = file
        self.cursor = cursor
        self.size = size
        self.lines = lines
        self.truncated = truncated
        self.reset = reset
    }
    private enum CodingKeys: String, CodingKey {
        case file
        case cursor
        case size
        case lines
        case truncated
        case reset
    }
}

public struct ExecApprovalsGetParams: Codable, Sendable {
}

public struct ExecApprovalsSetParams: Codable, Sendable {
    public let file: [String: AnyCodable]
    public let basehash: String?

    public init(
        file: [String: AnyCodable],
        basehash: String?
    ) {
        self.file = file
        self.basehash = basehash
    }
    private enum CodingKeys: String, CodingKey {
        case file
        case basehash = "baseHash"
    }
}

public struct ExecApprovalsNodeGetParams: Codable, Sendable {
    public let nodeid: String

    public init(
        nodeid: String
    ) {
        self.nodeid = nodeid
    }
    private enum CodingKeys: String, CodingKey {
        case nodeid = "nodeId"
    }
}

public struct ExecApprovalsNodeSetParams: Codable, Sendable {
    public let nodeid: String
    public let file: [String: AnyCodable]
    public let basehash: String?

    public init(
        nodeid: String,
        file: [String: AnyCodable],
        basehash: String?
    ) {
        self.nodeid = nodeid
        self.file = file
        self.basehash = basehash
    }
    private enum CodingKeys: String, CodingKey {
        case nodeid = "nodeId"
        case file
        case basehash = "baseHash"
    }
}

public struct ExecApprovalsSnapshot: Codable, Sendable {
    public let path: String
    public let exists: Bool
    public let hash: String
    public let file: [String: AnyCodable]

    public init(
        path: String,
        exists: Bool,
        hash: String,
        file: [String: AnyCodable]
    ) {
        self.path = path
        self.exists = exists
        self.hash = hash
        self.file = file
    }
    private enum CodingKeys: String, CodingKey {
        case path
        case exists
        case hash
        case file
    }
}

public struct ExecApprovalRequestParams: Codable, Sendable {
    public let id: String?
    public let command: String
    public let cwd: AnyCodable?
    public let host: AnyCodable?
    public let security: AnyCodable?
    public let ask: AnyCodable?
    public let agentid: AnyCodable?
    public let resolvedpath: AnyCodable?
    public let sessionkey: AnyCodable?
    public let timeoutms: Int?

    public init(
        id: String?,
        command: String,
        cwd: AnyCodable?,
        host: AnyCodable?,
        security: AnyCodable?,
        ask: AnyCodable?,
        agentid: AnyCodable?,
        resolvedpath: AnyCodable?,
        sessionkey: AnyCodable?,
        timeoutms: Int?
    ) {
        self.id = id
        self.command = command
        self.cwd = cwd
        self.host = host
        self.security = security
        self.ask = ask
        self.agentid = agentid
        self.resolvedpath = resolvedpath
        self.sessionkey = sessionkey
        self.timeoutms = timeoutms
    }
    private enum CodingKeys: String, CodingKey {
        case id
        case command
        case cwd
        case host
        case security
        case ask
        case agentid = "agentId"
        case resolvedpath = "resolvedPath"
        case sessionkey = "sessionKey"
        case timeoutms = "timeoutMs"
    }
}

public struct ExecApprovalResolveParams: Codable, Sendable {
    public let id: String
    public let decision: String

    public init(
        id: String,
        decision: String
    ) {
        self.id = id
        self.decision = decision
    }
    private enum CodingKeys: String, CodingKey {
        case id
        case decision
    }
}

public struct DevicePairListParams: Codable, Sendable {
}

public struct DevicePairApproveParams: Codable, Sendable {
    public let requestid: String

    public init(
        requestid: String
    ) {
        self.requestid = requestid
    }
    private enum CodingKeys: String, CodingKey {
        case requestid = "requestId"
    }
}

public struct DevicePairRejectParams: Codable, Sendable {
    public let requestid: String

    public init(
        requestid: String
    ) {
        self.requestid = requestid
    }
    private enum CodingKeys: String, CodingKey {
        case requestid = "requestId"
    }
}

public struct DeviceTokenRotateParams: Codable, Sendable {
    public let deviceid: String
    public let role: String
    public let scopes: [String]?

    public init(
        deviceid: String,
        role: String,
        scopes: [String]?
    ) {
        self.deviceid = deviceid
        self.role = role
        self.scopes = scopes
    }
    private enum CodingKeys: String, CodingKey {
        case deviceid = "deviceId"
        case role
        case scopes
    }
}

public struct DeviceTokenRevokeParams: Codable, Sendable {
    public let deviceid: String
    public let role: String

    public init(
        deviceid: String,
        role: String
    ) {
        self.deviceid = deviceid
        self.role = role
    }
    private enum CodingKeys: String, CodingKey {
        case deviceid = "deviceId"
        case role
    }
}

public struct DevicePairRequestedEvent: Codable, Sendable {
    public let requestid: String
    public let deviceid: String
    public let publickey: String
    public let displayname: String?
    public let platform: String?
    public let clientid: String?
    public let clientmode: String?
    public let role: String?
    public let roles: [String]?
    public let scopes: [String]?
    public let remoteip: String?
    public let silent: Bool?
    public let isrepair: Bool?
    public let ts: Int

    public init(
        requestid: String,
        deviceid: String,
        publickey: String,
        displayname: String?,
        platform: String?,
        clientid: String?,
        clientmode: String?,
        role: String?,
        roles: [String]?,
        scopes: [String]?,
        remoteip: String?,
        silent: Bool?,
        isrepair: Bool?,
        ts: Int
    ) {
        self.requestid = requestid
        self.deviceid = deviceid
        self.publickey = publickey
        self.displayname = displayname
        self.platform = platform
        self.clientid = clientid
        self.clientmode = clientmode
        self.role = role
        self.roles = roles
        self.scopes = scopes
        self.remoteip = remoteip
        self.silent = silent
        self.isrepair = isrepair
        self.ts = ts
    }
    private enum CodingKeys: String, CodingKey {
        case requestid = "requestId"
        case deviceid = "deviceId"
        case publickey = "publicKey"
        case displayname = "displayName"
        case platform
        case clientid = "clientId"
        case clientmode = "clientMode"
        case role
        case roles
        case scopes
        case remoteip = "remoteIp"
        case silent
        case isrepair = "isRepair"
        case ts
    }
}

public struct DevicePairResolvedEvent: Codable, Sendable {
    public let requestid: String
    public let deviceid: String
    public let decision: String
    public let ts: Int

    public init(
        requestid: String,
        deviceid: String,
        decision: String,
        ts: Int
    ) {
        self.requestid = requestid
        self.deviceid = deviceid
        self.decision = decision
        self.ts = ts
    }
    private enum CodingKeys: String, CodingKey {
        case requestid = "requestId"
        case deviceid = "deviceId"
        case decision
        case ts
    }
}

public struct ChatHistoryParams: Codable, Sendable {
    public let sessionkey: String
    public let limit: Int?

    public init(
        sessionkey: String,
        limit: Int?
    ) {
        self.sessionkey = sessionkey
        self.limit = limit
    }
    private enum CodingKeys: String, CodingKey {
        case sessionkey = "sessionKey"
        case limit
    }
}

public struct ChatSendParams: Codable, Sendable {
    public let sessionkey: String
    public let message: String
    public let thinking: String?
    public let deliver: Bool?
    public let attachments: [AnyCodable]?
    public let timeoutms: Int?
    public let idempotencykey: String

    public init(
        sessionkey: String,
        message: String,
        thinking: String?,
        deliver: Bool?,
        attachments: [AnyCodable]?,
        timeoutms: Int?,
        idempotencykey: String
    ) {
        self.sessionkey = sessionkey
        self.message = message
        self.thinking = thinking
        self.deliver = deliver
        self.attachments = attachments
        self.timeoutms = timeoutms
        self.idempotencykey = idempotencykey
    }
    private enum CodingKeys: String, CodingKey {
        case sessionkey = "sessionKey"
        case message
        case thinking
        case deliver
        case attachments
        case timeoutms = "timeoutMs"
        case idempotencykey = "idempotencyKey"
    }
}

public struct ChatAbortParams: Codable, Sendable {
    public let sessionkey: String
    public let runid: String?

    public init(
        sessionkey: String,
        runid: String?
    ) {
        self.sessionkey = sessionkey
        self.runid = runid
    }
    private enum CodingKeys: String, CodingKey {
        case sessionkey = "sessionKey"
        case runid = "runId"
    }
}

public struct ChatInjectParams: Codable, Sendable {
    public let sessionkey: String
    public let message: String
    public let label: String?

    public init(
        sessionkey: String,
        message: String,
        label: String?
    ) {
        self.sessionkey = sessionkey
        self.message = message
        self.label = label
    }
    private enum CodingKeys: String, CodingKey {
        case sessionkey = "sessionKey"
        case message
        case label
    }
}

public struct ChatEvent: Codable, Sendable {
    public let runid: String
    public let sessionkey: String
    public let seq: Int
    public let state: AnyCodable
    public let message: AnyCodable?
    public let errormessage: String?
    public let usage: AnyCodable?
    public let stopreason: String?

    public init(
        runid: String,
        sessionkey: String,
        seq: Int,
        state: AnyCodable,
        message: AnyCodable?,
        errormessage: String?,
        usage: AnyCodable?,
        stopreason: String?
    ) {
        self.runid = runid
        self.sessionkey = sessionkey
        self.seq = seq
        self.state = state
        self.message = message
        self.errormessage = errormessage
        self.usage = usage
        self.stopreason = stopreason
    }
    private enum CodingKeys: String, CodingKey {
        case runid = "runId"
        case sessionkey = "sessionKey"
        case seq
        case state
        case message
        case errormessage = "errorMessage"
        case usage
        case stopreason = "stopReason"
    }
}

public struct UpdateRunParams: Codable, Sendable {
    public let sessionkey: String?
    public let note: String?
    public let restartdelayms: Int?
    public let timeoutms: Int?

    public init(
        sessionkey: String?,
        note: String?,
        restartdelayms: Int?,
        timeoutms: Int?
    ) {
        self.sessionkey = sessionkey
        self.note = note
        self.restartdelayms = restartdelayms
        self.timeoutms = timeoutms
    }
    private enum CodingKeys: String, CodingKey {
        case sessionkey = "sessionKey"
        case note
        case restartdelayms = "restartDelayMs"
        case timeoutms = "timeoutMs"
    }
}

public struct TickEvent: Codable, Sendable {
    public let ts: Int

    public init(
        ts: Int
    ) {
        self.ts = ts
    }
    private enum CodingKeys: String, CodingKey {
        case ts
    }
}

public struct ShutdownEvent: Codable, Sendable {
    public let reason: String
    public let restartexpectedms: Int?

    public init(
        reason: String,
        restartexpectedms: Int?
    ) {
        self.reason = reason
        self.restartexpectedms = restartexpectedms
    }
    private enum CodingKeys: String, CodingKey {
        case reason
        case restartexpectedms = "restartExpectedMs"
    }
}
