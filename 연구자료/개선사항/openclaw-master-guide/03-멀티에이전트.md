# 섹션 3: 멀티에이전트 아키텍처 분석

## 3.1 텔레그램 멀티에이전트 아키텍처

### OpenClaw 멀티에이전트 구조
```
┌─────────────────────────────────────────────┐
│              OpenClaw Gateway                │
│         (단일 프로세스, 다중 에이전트)         │
├─────────┬──────────┬──────────┬─────────────┤
│ 세나    │ 미루     │ 하나     │ 유리        │
│ (팀장)  │ (리서처) │ (빌더)  │ (비평가)    │
│ Opus    │ Flash    │ Flash   │ Flash       │
├─────────┴──────────┴──────────┴─────────────┤
│              공유 인프라                      │
│  - 세션 스토어    - 스킬 시스템              │
│  - 크론 스케줄러  - 채널 커넥터              │
└─────────────────────────────────────────────┘
         │              │              │
    WhatsApp       Telegram       Discord
```

### 에이전트 격리 범위
| 항목 | 격리됨 | 공유됨 |
|------|--------|--------|
| 워크스페이스 (파일) | ✅ | |
| 세션 (대화 기록) | ✅ | |
| auth-profiles.json | ✅ | |
| SOUL.md / AGENTS.md | ✅ | |
| MEMORY.md | ✅ | |
| Gateway 프로세스 | | ✅ |
| 채널 커넥터 | | ✅ |
| ~/.openclaw/skills | | ✅ (관리 스킬) |
| 워크스페이스 스킬 | ✅ | |

## 3.2 에이전트 간 통신 방식 비교

### 방식 1: sessions_send (A2A 직접 메시징)
```
세나 → sessions_send(miru, "이거 리서치해줘") → 미루
```
- **장점**: 직접적, 즉시 응답, 컨텍스트 전달 가능
- **단점**: 세션 키 필요, 동기적 대기
- **설정**: `tools.agentToAgent.enabled: true`

### 방식 2: sessions_spawn (서브에이전트)
```
세나 → sessions_spawn(task: "리서치해줘", agentId: "miru") → 격리 세션에서 실행 → 결과 반환
```
- **장점**: 완전 격리, 타임아웃 제어, 실패 격리
- **단점**: 오버헤드, agentId allowlist 필요
- **설정**: `agents.list[].subagents.allowAgents: ["miru"]` 또는 `subagents.autoDiscoverAgents: true`로 전체 허용

### 방식 3: 텔레그램 그룹 @멘션
```
그룹 메시지 "@miru 리서치해줘" → Gateway가 miru 에이전트로 라우팅
```
- **장점**: 자연스러운 UX, 사용자도 참여 가능
- **단점**: 텔레그램 의존, 에이전트 간 직접 대화 어려움
- **설정**: 에이전트별 `mentionPatterns` 설정

### 방식 4: 공유 파일 (워크스페이스)
```
세나가 파일 작성 → 미루가 같은 파일 읽기
```
- **장점**: 비동기, 큰 데이터 전달 가능
- **단점**: 동기화 문제, 충돌 위험
- **설정**: 공유 디렉토리 마운트

### 방식 5: 웹훅 (외부 트리거)
```
외부 이벤트 → 웹훅 → Gateway → 에이전트
```
- **장점**: 외부 시스템 연동
- **단점**: 에이전트 간 직접 통신은 아님
- **설정**: `automation.webhook` 설정

### 통신 방식 비교표

| 방식 | 실시간성 | 격리 | 복잡도 | 양방향 | 권장 용도 |
|------|---------|------|--------|--------|----------|
| sessions_send | ⭐⭐⭐ | 낮음 | 낮음 | ✅ | 팀 대화, 빠른 질문 |
| sessions_spawn | ⭐⭐ | 높음 | 중간 | ❌ (결과만) | 독립 작업 위임 |
| @멘션 (그룹) | ⭐⭐⭐ | 중간 | 낮음 | ✅ | 사용자 참여 토론 |
| 공유 파일 | ⭐ | 낮음 | 낮음 | ✅ | 대용량 데이터 |
| 웹훅 | ⭐⭐ | 높음 | 높음 | ❌ | 외부 이벤트 |

## 3.3 오케스트레이터 패턴 비교

### 패턴 1: Hub-and-Spoke (허브 중심)
```
         세나 (허브)
        / | \
      미루 하나 유리
```
- **특징**: 중앙 에이전트가 모든 조율. OpenClaw의 기본 패턴.
- **장점**: 예측 가능, 디버깅 쉬움
- **단점**: 허브 병목, 단일 장애점
- **적합**: 팀 관리, 프로젝트 조율

### 패턴 2: Peer-to-Peer (직접 소통)
```
      미루 ↔ 하나
       ↕      ↕
      유리 ↔ 세나
```
- **특징**: 에이전트끼리 직접 소통. sessions_send로 구현.
- **장점**: 병목 없음, 유연
- **단점**: 혼잡, 조율 어려움
- **적합**: 브레인스토밍, 자유 토론

### 패턴 3: Pipeline (순차 처리)
```
미루(리서치) → 하나(구현) → 유리(검증) → 세나(종합)
```
- **특징**: 단계별 순차 실행. CrewAI의 기본 패턴.
- **장점**: 명확한 흐름, 품질 제어
- **단점**: 느림, 유연성 부족
- **적합**: 문서 작성, 코드 리뷰 파이프라인

### 패턴 4: Broadcast (동시 실행)
```
세나 → [미루, 하나, 유리] 동시 실행 → 세나가 종합
```
- **특징**: 같은 질문을 여러 에이전트에게 동시에. sessions_spawn 병렬 호출.
- **장점**: 빠름, 다양한 관점
- **단점**: 비용 높음, 중복 작업
- **적합**: 다관점 분석, 의견 수렴

### 패턴 비교 (외부 프레임워크 참조)

| 프레임워크 | 기본 패턴 | 특징 |
|-----------|----------|------|
| **OpenClaw** | Hub-and-Spoke | 로컬 실행, 채널 통합, 유연한 라우팅 |
| **CrewAI** | Pipeline (순차) | 역할 기반, 간단한 설정, 직렬 실행 |
| **LangGraph** | DAG (그래프) | 상태 관리, 조건부 분기, 체크포인트 |
| **AutoGen** | 대화 기반 | 에이전트 간 자유 대화, 유연 |
| **OpenAI Swarm** | 핸드오프 | 경량, 에이전트 간 전환 |

## 3.4 역할 분담 최적 구조

### 추천 구조 1: 4인 팀 (현재 세나팀)
| 역할 | 담당 | 모델 | 핵심 스킬 |
|------|------|------|----------|
| 오케스트레이터 | 세나 | Opus | 종합, 판단, 사용자 소통 |
| 리서처 | 미루 | Flash/Sonnet | web_search, web_fetch, summarize |
| 빌더 | 하나 | Flash/Sonnet | exec, write, edit, github |
| 비평가 | 유리 | Flash/Sonnet | 팩트체크, 보안 검토 |

### 추천 구조 2: 5인 팀 (확장)
| 역할 | 추가 에이전트 | 핵심 역할 |
|------|-------------|----------|
| + 모니터 | 워치 | 크론 기반 자동 모니터링 (뉴스, 이슈, 시스템) |

### 추천 구조 3: 전문 분야별
| 역할 | 에이전트 | 핵심 역할 |
|------|---------|----------|
| 일상 비서 | 챗 | 일정, 날씨, 리마인더 (Sonnet) |
| 딥워크 | 디프 | 분석, 보고서, 전략 (Opus) |
| 코더 | 코드 | 코딩, 디버깅, PR (Sonnet) |
| 크리에이터 | 크리 | 콘텐츠, 디자인, 글쓰기 (Opus) |

### 역할별 프롬프트 템플릿

**오케스트레이터 (SOUL.md)**
```markdown
나는 팀장. 팀원들의 작업을 조율하고 최종 결과물을 만든다.
- 작업 분배 시 각 팀원의 강점 활용
- 결론을 먼저 내리고 근거를 제시
- 최대 3라운드 토론 후 합의
```

**리서처 (SOUL.md)**
```markdown
나는 리서처. 데이터와 근거로 말한다.
- 검색 시 최신 자료 우선
- 출처 항상 명시
- 숫자와 팩트 중심
```

**빌더 (SOUL.md)**
```markdown
나는 빌더. 실용적 구현에 집중한다.
- 작동하는 코드/설정 제공
- 비용과 복잡도 항상 고려
- 테스트 가능한 결과물
```

**비평가 (SOUL.md)**
```markdown
나는 비평가. 약점을 찾고 개선점을 제시한다.
- 모든 주장에 반례 검토
- 보안/성능/비용 관점 우선
- 비판 시 대안 반드시 제시
```

## 3.5 세나팀 실전 경험 & 교훈

### 팀 구성
- **세나** (팀장/오케스트레이터) — claude-opus-4-5
- **미루** (리서처) — gemini-3-flash (구: glm-4.7)
- **하나** (빌더) — gemini-3-flash (구: glm-4.7)
- **유리** (비평가) — gemini-3-flash (구: glm-4.7)

### 실전 트러블 & 해결

**1. glm-4.7 도구 호출 버그 (치명적)**
- 증상: sessions_spawn으로 팀원 호출 시 6회 테스트 중 0회 성공
- 원인: glm-4.7이 tool call을 thinking/reasoning 블록에 삽입 (OpenCode #6708, OpenClaw #1712)
- 해결: gemini-3-flash로 모델 변경

**2. sessions_spawn agentId 제한**
- 증상: `sessions_spawn(agentId: "miru")` → "agentId is not allowed" 에러
- 원인: spawn allowlist에 팀원 에이전트 미등록
- 해결: 설정에서 `agents.list[].subagents.allowAgents` 배열에 등록 필요
- 임시 대안: 세나가 직접 모든 작업 수행 (1인 풀 리서치)

**3. sessions_send 세션 키 문제**
- 증상: `sessions_send(agentId: "miru")` → "sessionKey or label required" 에러
- 원인: sessions_send는 agentId가 아닌 sessionKey/label 필요
- 해결: sessions_spawn 사용하거나, 텔레그램 그룹 @멘션 방식으로 전환

**4. 프로바이더 버전 만료**
- 증상: "version no longer supported" 에러
- 원인: google-antigravity 프로바이더 서버 측 차단
- 해결: OpenClaw 업데이트 또는 다른 프로바이더로 전환 필요

**5. auth-profiles.json 복사 필수**
- 발견: 메인 에이전트 인증이 팀원 에이전트에 공유 안 됨
- 해결: `~/.openclaw/agents/sena/agent/auth-profiles.json`을 각 팀원 agentDir에 복사

### 핵심 교훈
1. **모델 선택이 멀티에이전트의 성패를 좌우**: 도구 호출 능력이 약한 모델은 서브에이전트로 쓸 수 없음
2. **spawn > send**: 에이전트 간 통신은 sessions_spawn이 더 안정적 (격리 + 타임아웃)
3. **fallback 전략 필수**: 팀원 호출 실패 시 오케스트레이터가 직접 처리하는 경로 확보
4. **설정 먼저, 실행 나중**: A2A, spawn allowlist, auth 복사 등 선행 설정 체크리스트 필요

## 3.6 MCP & A2A 프로토콜 동향

### MCP (Model Context Protocol) - Anthropic
- 에이전트가 외부 도구/DB/API에 연결하는 표준 프로토콜
- OpenClaw은 스킬 시스템이 MCP와 유사한 역할 수행
- 2025~2026년 업계 표준으로 자리잡는 중

### A2A (Agent-to-Agent) - Google
- 에이전트 간 상호운용성을 위한 프로토콜
- OpenClaw의 sessions_send/spawn이 내부 A2A 역할
- 향후 외부 에이전트 연동 가능성

### 핵심 트렌드 (2026)
1. **멀티에이전트 → 표준화**: MCP/A2A로 프레임워크 간 상호운용
2. **분산 시스템화**: 에이전트를 마이크로서비스처럼 관리
3. **상태 관리**: 에이전트 간 공유 상태 + 충돌 해결이 핵심 과제
4. **안전성**: 에이전트 간 권한 경계 + 프롬프트 인젝션 방어

---

## 출처
- [OpenClaw 공식 문서 - Multi-Agent Routing](https://docs.openclaw.ai/concepts/multi-agent)
- [DataCamp: CrewAI vs LangGraph vs AutoGen](https://www.datacamp.com/tutorial/crewai-vs-langgraph-vs-autogen)
- [MachineLearningMastery: 7 Agentic AI Trends 2026](https://machinelearningmastery.com/7-agentic-ai-trends-to-watch-in-2026/)
- [DEV.to: How to Build Multi-Agent Systems 2026](https://dev.to/eira-wexford/how-to-build-multi-agent-systems-complete-2026-guide-1io6)
- [Multi-Agent Orchestration Enterprise Strategy 2025-2026](https://www.onabout.ai/p/mastering-multi-agent-orchestration-architectures-patterns-roi-benchmarks-for-2025-2026)
- [Towards AI: 4 Best Multi-Agent Frameworks 2026](https://pub.towardsai.net/the-4-best-open-source-multi-agent-ai-frameworks-2026-9da389f9407a)
- [Galileo: AutoGen vs CrewAI vs LangGraph](https://galileo.ai/blog/autogen-vs-crewai-vs-langgraph-vs-openai-agents-framework)
